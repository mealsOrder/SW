Kruskal(G)
{
  MST <- {}; // MST는 최소신장트리
  단 하나의 정점만으로 이루어진 n개의 집합을 S로 초기화 한다;
  모든 간선을 가중치가 작은 순으로 정렬한다;
  while (T의 간선수 < n-1){
    최소비용 간선 (u, v)를 제거한다;
    정점 u와 정점 v가 서로 다른 집합에 속하면{
      두 집합을 하나로 합친다;
      T <- T + {(u, v)};}
  }
}

알고리즘 Kruskal의_최소_신장_트리_계산
입력: 그래프 G의 정점 수와 간선 리스트
출력: MST의 총 가중치, 각 컴포넌트의 비용 및 노드 수, 위험도

1. 그래프 G를 생성하고, 각 정점에 대해 자기 자신을 부모로 설정하여 초기화한다.
2. 모든 간선을 가중치에 따라 오름차순으로 정렬한다.
3. MST 집합과 각 컴포넌트의 노드 집합을 초기화한다.

4. 정렬된 간선들에 대해 반복:
   a. 간선 (u, v)를 하나씩 가져온다.
   b. u와 v의 루트를 찾는다 (경로 압축을 사용하여).
   c. u와 v가 서로 다른 집합에 속해있다면:
      i. 두 집합을 하나로 합친다 (랭크를 기준으로).
      ii. 이 간선을 MST에 추가한다.
      iii. u와 v를 포함하는 컴포넌트의 노드 집합에 각 노드를 추가한다.

5. 각 컴포넌트에 대해 반복:
   a. 해당 컴포넌트 내 모든 노드를 포함하는 간선의 가중치를 합산하여 컴포넌트의 비용을 계산한다.
   b. 컴포넌트의 노드 수를 합산한다.

6. 모든 컴포넌트의 비용을 합산하고, MST의 총 가중치를 계산한다.
7. 위험도를 계산:
   a. 계산값 C를 구한다: C = 100000 / MST의 총 가중치
   b. 계산값 G를 구한다: G = 0.5 * 로그10(컴포넌트 수 + 1) * e^(총 노드 수)
   c. 위험도 R을 계산한다: R = 루트(로그10(C) * 총 노드 수 * G)

8. 결과 출력:
   a. 각 컴포넌트의 노드 수
   b. 연결된 그래프의 개수
   c. 연결된 노드 수
   d. 코스트의 합
   e. MST의 총 가중치
   f. 계산값 C, G
   g. 위험도 R

9. 알고리즘 종료


Kruskal(G) {
  MST <- 빈 집합; // MST는 최소 신장 트리를 나타낸다.
  S <- 각각 단 하나의 정점만을 포함하는 n개의 집합으로 초기화; // n은 그래프 G의 정점 수

  // 모든 간선을 가중치가 작은 순으로 정렬
  모든 간선을 가중치에 따라 오름차순으로 정렬한다;

  // 최소 스패닝 숲 구성
  for each (u, v, weight) in 정렬된 간선 리스트 {
    if (Find(u) != Find(v)) { // u와 v가 서로 다른 집합에 속해있다면
      Union(u, v); // u와 v가 속한 집합을 합친다.
      MST <- MST + {(u, v, weight)}; // 합쳐진 집합에 간선 (u, v)를 추가
    }
  }

  // 연결되지 않은 노드 확인
  연결되지 않은 노드 집합 <- 빈 집합;
  for each 정점 i from 0 to n-1 {
    if (Find(i) == i) { // 자신의 부모가 자신인 정점은 독립된 컴포넌트의 루트
      연결되지 않은 노드 집합에 i를 추가;
    }
  }

  // 결과 출력
  출력 "연결되지 않은 노드:";
  for each 노드 in 연결되지 않은 노드 집합 {
    출력 노드;
  }
  출력 줄바꿈;

  // MST 출력
  출력 "Minimum Spanning Forest 구성:";
  for each (u, v, weight) in MST {
    출력 u, " - ", v, " (가중치: ", weight, ")";
  }
  출력 "Minimum Spanning Forest 총 비용: ", MST의 총 가중치;
}